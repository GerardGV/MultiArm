### Selecciona un idioma | Select a language:
* <a href="#catala">Catal√†</a>
* <a href="#castellano">Castellano</a>
* <a href="#english">English</a>
---

<img src="imgREADMEs/imgREADME_RLP/imgMultiArmHeader.jpeg?raw=true" align="right" width="300" alt="MultiArm Header Image"/>  
<h1 id="catala"> MultiArm </h1>
Projecte conjunt de les assignatures de Rob√≤tica (RLP), Visi√≥ per Computador (VC) i Sistemes Multim√®dia (SM) en el qual hem desenvolupat un bra√ß robotic amb visi√≥ per computador per a realitzar operacions quir√∫rgiques remotament via Internet.


# Taula de continguts:
   * [Qu√® √©s aquest repositori?](#qu√®-√©s-aquest-repositori)
   * [Requisits](#requisits)
     * [Hardware](#hardware)
     * [Software](#software)
   * [Documentaci√≥](#documentaci√≥)
   * [Guia d'√∫s](#guia-d√∫s)
   * [Esquema del Hardware](#esquema-del-hardware)
   * [Arquitectura del Software](#arquitectura-del-software)
   * [Models 3D](#models-3d)
   * [Autors](#autors)

# Qu√® √©s aquest repositori?

En aquest repositori es troba tot el codi, models del robot explicaci√≥ necessaris per tal d'entendre qu√® hem fet durant el proc√©s de desenvolupament d'aquest projecte amb l'objectiu de poder replicar-lo i millorar-lo en un futur.

### Codi.
Trobem el codi separat en 3 carpetes principals:
- **Kinematics:** En aquesta carpeta es troba tot el codi d'Arduino desenvolupat.
- **cloud:** S'hi pot trobar el codi que s'ha d'executar per tal de controlar remotament el robot. Tenim el servidor, el client del robot, el client de l'usuari i l'aplicaci√≥.
- **Computer Vision:** Cont√© el codi implementat durant la realitzaci√≥ de la pr√†ctica de Visi√≥ per Computador, durant la qual vam implementar l'algorisme SIFT manual, el proc√©s necessari per realitzar una primera reconstrucci√≥ donades dues imatges i la comparaci√≥ de diversos algorismes similars.

# Requisits:

Llistarem els requisits necessaris per portar a terme el nostre projecte, tant el muntatge del robot (sense comptar cables, cargols, etc) com 
l'execuci√≥ del nostre Software amb les depend√®ncies o requeriments que comportin.

## Hardware:
- 3 x motor pas a pas (28BYJ-48)
- 3 x  Controladora de motors de pas a pas (28BYJ-48) (Controladora ULN2003 7 IN pins i de 5-12V)
- 1 x Micro Metal Gearmotor HP (micromotor de gir Continu)
- 1 x Controladora de motor (micromotor de gir) DF-MD V1.3
- 1 x Fuente de alimentaci√≥n TACENS anima APII 500
- 1 x Placa de prototipo (Protoboard) 16,5x5,5cm
- 1 x Arduino UNO Rev.3
- 1 x Raspberry pi Zero
- 1 x M√≤dul de c√†mera Raspberry Pi Camera v2

## Software:
- [Python 3.10.x](https://www.python.org/)
  - [NumPy](https://numpy.org/)
  - [PyGame](https://www.pygame.org/news)
  - [cv2 (openCV)](https://pypi.org/project/opencv-python/)
  - [time](https://docs.python.org/3/library/time.html)
  - [sys](https://docs.python.org/3/library/sys.html)
  - [socket](https://docs.python.org/3/library/socket.html)
  - [picamera](https://picamera.readthedocs.io/en/latest/)
  - [serial](https://pyserial.readthedocs.io/en/latest/)
  - [google-cloud](https://googleapis.dev/python/google-api-core/latest/index.html)
  - [google-cloud-storage](https://googleapis.dev/python/storage/latest/index.html)
  - [google-auth](https://google-auth.readthedocs.io/en/latest/)
  - [google-auth-oauthlib](https://google-auth-oauthlib.readthedocs.io/en/latest/)
  - [google.oauth2](https://google-auth.readthedocs.io/en/latest/reference/google.oauth2.html)
  - [json](https://docs.python.org/3/library/json.html)
  - [Flask](https://flask.palletsprojects.com/en/2.3.x/)
- [Arduino IDE](https://www.arduino.cc/en/software)
  - [AccelStepper - Arduino Library](https://www.airspayce.com/mikem/arduino/AccelStepper/)
- [Google Cloud Platform (GCP)](https://cloud.google.com/gcp/)

# Documentaci√≥:
Aquest README cont√© informaci√≥ del nostre robot, i un context general de les parts de visi√≥ per computador i del Cloud, desenvolupat a Sistemes Multim√®dia.
Si est√†s interessat en con√®ixer m√©s detalls dels respectius projectes, pots mirar:
* [Visi√≥ per Computador: Implementaci√≥ de l'algorisme SIFT i modelat 3D](https://github.com/GerardGV/MultiArm/tree/main/Computer%20Vision) on aprofundim m√©s sobre l'algorisme implementat per detectar punts caracter√≠stics de dues imatges i despr√©s visualitzar-los en l'aplicaci√≥.
* [Sistemes Multim√®dia: Projecte al Cloud](https://github.com/GerardGV/MultiArm/tree/main/cloud) on aprofundim m√©s sobre l'arquitectura de comunicacions desenvolupada en el Cloud allotjat a Google Cloud, l'aplicaci√≥, el seu funcionament i peticions amb el servidor realitzades.

# Guia d'√∫s:
1. Clone this repository.
    ```terminal
    git clone https://github.com/GerardGV/MultiArm.git
    ```
2. Install Python and the required libraries. 
    ```terminal
    pip install -r requirements.txt
    ```
3. Open the server (execute the cloud/server.py) file
    ```terminal
    python3 cloud/server.py
    ```
4. Open the App (execute the cloud/app.py)
    ```terminal
    python3 cloud/app.py
    ```
5. Open the clientRobot.py and turn on the Robot
    ```terminal
    python3 cloud/clientRobot.py
    ```
6. Enjoy!! üòÑ TIP: You can check the Cloud folder README.md to understand the WorkFlow of our app. 

# Esquema del Hardware
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/hardware_scheme.jpg" alt= "Hardware Scheme" />
</p>
Nota: El motor DC M1 est√° connectat a una controladora que el programa Fritzing no mostra a l'esquema. 
El nostre esquema de HW esta compost pels 3 motors steppers connectats cadasc√∫n a la seva controladora i als pins correspondents a la Arduino i un motor DC connectat a la seva controladora i als pins 12 i 13 d‚ÄôArduino. Tots aquests motors estan connectats a una font d‚Äôalimentaci√≥.

# Arquitectura del Software
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/software_architecture.png" alt= "Software Architecture" />
</p>

- M√≤dul comunicaci√≥ User: funci√≥ que rep els seg√ºents par√†metres:
  - Socket: socket conectat al servidor
  - Instrucci√≥: funcionalitat del missatge
  - Missatge: la informaci√≥ que es desitja enviar.
  - Retorna punts 2D en cas de demanar que el 
  - Amb aquests par√†metres cridar√† al m√≤dul de jsonSetUp i formalizar√° un json per enviar a trav√©s del socket.
- M√≤dul de Visualitzaci√≥ : visualitzaci√≥ del rostre escanejat en un espai 2D, segons la versi√≥ de l'aplicaci√≥ que s‚Äôutilitzi..
- M√≤dul jsonSetUp: formalitza els parametres instruction i message per retornar un json.
- M√≤dul de connexions: rep un IP i el port per retornar una connexi√≥ socket.
- M√≤dul de instruccions: men√∫ a l‚Äôaplicai√≥ de l‚Äôusuari per rebre les ordres.
- M√≤dul User: aplicaci√≥ formada per els m√≤duls de visualitzaci√≥ i d‚Äôinstruccions en conjunt amb un m√≤dul de connexi√≥ que permet comunicar-se via socket amb el servidor.
- Cloud function: algorisme de visi√≥ per computador que retorna els punts caracter√≠stics de les dues imatges enviades del robot al cloud storage bucket.
- M√≤dul server: m√°quina virtual que executa un python script que permet les connexions via socket amb el User i el robot. T√© regles firewall afegides en la seva red del cloud per permetre les connexions.
- M√≤dul Bucket, cloud storage: emmagatzema les imatges fetes pero el bra√ß rob√≥tic.
- M√≤dul Robot: python script format per un m√≤dul de connexi√≥ y que envia les ordres al arduino per a que cridi als m√≤duls corresponents.
- M√≤dul control Camara: rep la instrucci√≥ de captar les dades biom√®triques.
- M√≤dul Control de Motors: rep les ordres de moviment per a cada motor.
- M√≤dul canvi de cap√ßal: model al qual crida el robot quan vol cambiar de cap√ßal. Si no te cap cap√ßal, anira i agafara l‚Äô1, el rotulador, si t√© el retolador, anir√† a deixar el segon cap√ßal.
- M√≤dul control camera: modul que retorna imatges fetes per la camera de la raspberry
- M√≤dul inverse_kinematics:modul de l‚Äôarduino que rep les instruccions de la raspberry y crida a control de motors segons l‚Äôinstrucci√≥.
- M√≤dul comunicaci√≥ Robot:  rep la connexi√≥ socket i envia les ordres al robot, arduino, i retorna informaci√≥ al servidor, les imatges.
                                                                                  
# Models 3D: 
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/3d_models.jpeg" alt= "3D models" />
</p>

En aquesta imatge trobem els diversos models 3D que formen el nostre robot. En el nostre cas, els hem impr√®s mitjan√ßant una impresora 3D amb PLA.

# Millores en un futur:
* Millorar la visualitzaci√≥ de punts per tal que es realitzi una visualitzaci√≥ de punts 3D millor. Desenvolupar el software necessari per tal que tota l'aplicaci√≥ funcioni amb aquesta visualitzaci√≥ implementada que permeti rotar la c√†mera: 
![]()
* Millorar l'algor√≠smica del robot per controlar millor la profunditat i evitar tallades al pacient, per√≤ per millorar aix√≤, √©s necessari que per la part de Visi√≥ per Computador s'aconsegueixi fer un meshing i texturitzaci√≥ del model per tal de detectar correctament tots els punts amb precisi√≥. D'aquesta manera hi hauria millor interacci√≥ Cirurgi√† - Robot. Aquesta feina √©s complicada i s'hi ha de dedicar molt de temps, per√≤ creiem que √©s un coll d'ampolla important a superar, doncs el canvi que es pot realitzar en el projecte √©s gran.
* Controlar la temperatura dels motors, millorar la refrigeraci√≥ o canviar el material de construcci√≥ del robot, ja que despr√©s de bastantes proves o d'execucions llargues, els engranatges m√©s petits que es troben en contacte directe amb els motors es fonen, perdent aix√≠ moviment del robot.

# Autors:
* Pol Colomer Campoy (1605612) | PolKinsa
* Gerard Josep Guarin Velez (1605947) | GerardGV
* Jan Rubio Rico (1603753) | TheRospetit
* Rub√©n Sim√≥ Marin (1569391)
---
---

<h1 id= "castellano"> MultiArm </h1>
Proyecto conjunto de las asignaturas de Rob√≥tica (RLP), Visi√≥n por Computadora (VC) y Sistemas Multimedia (SM) en el cual hemos desarrollado un brazo rob√≥tico con visi√≥n por computadora para realizar operaciones quir√∫rgicas de manera remota a trav√©s de Internet.

## Tabla de contenidos:
   * [¬øQu√© es este repositorio?](#qu√©-es-este-repositorio)
   * [Requisitos](#requisitos)
     * [Hardware](#hardware)
     * [Software](#software)
   * [Documentaci√≥n](#documentaci√≥n)
   * [Gu√≠a de uso](#gu√≠a-de-uso)
   * [Esquema del Hardware](#esquema-del-hardware)
   * [Arquitectura del Software](#arquitectura-del-software)
   * [Modelos 3D](#modelos-3d)
   * [Autores](#autores)

# ¬øQu√© es este repositorio?

En este repositorio se encuentra todo el c√≥digo, modelos del robot y explicaciones necesarias para entender lo que hemos hecho durante el proceso de desarrollo de este proyecto, con el objetivo de poder replicarlo y mejorarlo en el futuro.

### C√≥digo.
El c√≥digo est√° organizado en 3 carpetas principales:
- **Kinematics:** En esta carpeta se encuentra todo el c√≥digo de Arduino desarrollado.
- **cloud:** Aqu√≠ se puede encontrar el c√≥digo que se debe ejecutar para controlar remotamente el robot. Tenemos el servidor, el cliente del robot, el cliente del usuario y la aplicaci√≥n.
- **Computer Vision:** Contiene el c√≥digo implementado durante la realizaci√≥n de la pr√°ctica de Visi√≥n por Computadora, en la cual implementamos el algoritmo SIFT manual, el proceso necesario para realizar una reconstrucci√≥n inicial dadas dos im√°genes y la comparaci√≥n de varios algoritmos similares.

# Requisitos:

Enumeraremos los requisitos necesarios para llevar a cabo nuestro proyecto, tanto el ensamblaje del robot (sin contar cables, tornillos, etc.) como la ejecuci√≥n de nuestro Software con las dependencias o requerimientos que conlleve.

## Hardware:
- 3 x motor paso a paso (28BYJ-48)
- 3 x Controladora de motores paso a paso (28BYJ-48) (Controladora ULN2003 con 7 pines IN y voltaje de 5-12V)
- 1 x Micro Motor de Engranajes HP (micromotor de giro continuo)
- 1 x Controladora de motor (micromotor de giro) DF-MD V1.3
- 1 x Fuente de alimentaci√≥n TACENS anima APII 500
- 1 x Placa de prototipo (Protoboard) 16,5x5,5cm
- 1 x Arduino UNO Rev.3
- 1 x Raspberry Pi Zero
- 1 x M√≥dulo de c√°mara Raspberry Pi Camera v2

## Software:
- [Python 3.10.x](https://www.python.org/)
  - [NumPy](https://numpy.org/)
  - [PyGame](https://www.pygame.org/news)
  - [cv2 (openCV)](https://pypi.org/project/opencv-python/)
  - [time](https://docs.python.org/3/library/time.html)
  - [sys](https://docs.python.org/3/library/sys.html)
  - [socket](https://docs.python.org/3/library/socket.html)
  - [picamera](https://picamera.readthedocs.io/en/latest/)
  - [serial](https://pyserial.readthedocs.io/en/latest/)
  - [google-cloud](https://googleapis.dev/python/google-api-core/latest/index.html)
  - [google-cloud-storage](https://googleapis.dev/python/storage/latest/index.html)
  - [google-auth](https://google-auth.readthedocs.io/en/latest/)
  - [google-auth-oauthlib](https://google-auth-oauthlib.readthedocs.io/en/latest/)
  - [google.oauth2](https://google-auth.readthedocs.io/en/latest/reference/google.oauth2.html)
  - [json](https://docs.python.org/3/library/json.html)
  - [Flask](https://flask.palletsprojects.com/en/2.3.x/)
- [Arduino IDE](https://www.arduino.cc/en/software)
  - [AccelStepper - Arduino Library](https://www.airspayce.com/mikem/arduino/AccelStepper/)
- [Google Cloud Platform (GCP)](https://cloud.google.com/gcp/)

# Documentaci√≥n:
Este README contiene informaci√≥n de nuestro robot y un contexto general de las partes de visi√≥n por computadora y de Cloud desarrolladas en Sistemas Multimedia.
Si est√°s interesado en conocer m√°s detalles de los respectivos proyectos, puedes mirar:
* [Visi√≥n por Computadora: Implementaci√≥n del algoritmo SIFT y modelado 3D](https://github.com/GerardGV/MultiArm/tree/main/Computer%20Vision), donde profundizamos m√°s sobre el algoritmo implementado para detectar puntos caracter√≠sticos en dos im√°genes y luego visualizarlos en la aplicaci√≥n.
* [Sistemas Multimedia: Proyecto en el Cloud](https://github.com/GerardGV/MultiArm/tree/main/cloud), donde profundizamos m√°s sobre la arquitectura de comunicaciones desarrollada en el Cloud alojado en Google Cloud, la aplicaci√≥n, su funcionamiento y las solicitudes realizadas al servidor.

# Gu√≠a de uso:
1. Clona este repositorio.
    ```terminal
    git clone https://github.com/GerardGV/MultiArm.git
    ```
2. Instala Python y las bibliotecas requeridas. 
    ```terminal
    pip install -r requirements.txt
    ```
3. Abre el archivo server.py en la carpeta cloud y ejec√∫talo.
    ```terminal
    python3 cloud/server.py
    ```
4. Abre la aplicaci√≥n (ejecuta el archivo app.py en la carpeta cloud).
    ```terminal
    python3 cloud/app.py
    ```
5. Abre el archivo clientRobot.py y enciende el robot.
    ```terminal
    python3 cloud/clientRobot.py
    ```
6. ¬°Disfruta! üòÑ CONSEJO: Puedes consultar el archivo README.md de la carpeta Cloud para comprender el flujo de trabajo de nuestra aplicaci√≥n.

# Esquema del Hardware
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/hardware_scheme.jpg" alt="Esquema del Hardware" />
</p>
Nota: El motor DC M1 est√° conectado a un controlador que el programa Fritzing no muestra en el esquema. 
Nuestro esquema de HW est√° compuesto por los 3 motores paso a paso conectados cada uno a su controlador y a los pines correspondientes en Arduino, y un motor DC conectado a su controlador y a los pines 12 y 13 de Arduino. Todos estos motores est√°n conectados a una fuente de alimentaci√≥n.

# Arquitectura del Software
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/software_architecture.png" alt="Arquitectura del Software" />
</p>

- M√≥dulo comunicaci√≥n User: funci√≥n que recibe los siguientes par√°metros:
  - Socket: socket conectado al servidor.
  - Instrucci√≥n: funcionalidad del mensaje.
  - Mensaje: la informaci√≥n que se desea enviar.
  - Retorna puntos 2D en caso de solicitarlo.
  - Con estos par√°metros, llamar√° al m√≥dulo jsonSetUp y formalizar√° un json para enviar a trav√©s del socket.
- M√≥dulo de Visualizaci√≥n: visualizaci√≥n del rostro escaneado en un espacio 2D, seg√∫n la versi√≥n de la aplicaci√≥n que se est√© utilizando.
- M√≥dulo jsonSetUp: formaliza los par√°metros de instrucci√≥n y mensaje para retornar un json.
- M√≥dulo de conexiones: recibe una direcci√≥n IP y un puerto para establecer una conexi√≥n socket.
- M√≥dulo de instrucciones: men√∫ en la aplicaci√≥n del usuario para recibir las √≥rdenes.
- M√≥dulo User: aplicaci√≥n formada por los m√≥dulos de visualizaci√≥n e instrucciones, junto con un m√≥dulo de conexi√≥n que permite la comunicaci√≥n v√≠a socket con el servidor.
- Cloud function: algoritmo de visi√≥n por computadora que retorna los puntos caracter√≠sticos de las dos im√°genes enviadas del robot al cloud storage bucket.
- M√≥dulo server: m√°quina virtual que ejecuta un script de Python que permite las conexiones v√≠a socket con el User y el robot. Tiene reglas de firewall agregadas en su red del cloud para permitir las conexiones.
- M√≥dulo Bucket, cloud storage: almacena las im√°genes tomadas por el brazo rob√≥tico.
- M√≥dulo Robot: script de Python compuesto por un m√≥dulo de conexi√≥n que env√≠a las √≥rdenes al Arduino para que llame a los m√≥dulos correspondientes.
- M√≥dulo control C√°mara: recibe la instrucci√≥n de capturar los datos biom√©tricos.
- M√≥dulo Control de Motores: recibe las √≥rdenes de movimiento para cada motor.
- M√≥dulo cambio de cabezal: modelo al que llama el robot cuando quiere cambiar de cabezal. Si no tiene ning√∫n cabezal, ir√° y tomar√° el primero, el rotulador; si tiene el rotulador, ir√° a dejar el segundo cabezal.
- M√≥dulo control c√°mara: m√≥dulo que devuelve im√°genes tomadas por la c√°mara de la Raspberry.
- M√≥dulo inverse_kinematics: m√≥dulo del Arduino que recibe las instrucciones de la Raspberry y llama a control de motores seg√∫n la instrucci√≥n.
- M√≥dulo comunicaci√≥n Robot: recibe la conexi√≥n socket y env√≠a las √≥rdenes al robot (Arduino) y retorna informaci√≥n al servidor, como las im√°genes.

# Modelos 3D:
<p align="center">
  <img src="imgREADMEs/imgREADME_RLP/3d_models.jpeg" alt="Modelos 3D" />
</p>

En esta imagen encontramos los diversos modelos 3D que forman nuestro robot. En nuestro caso, los hemos impreso mediante una impresora 3D con PLA.

# Mejoras en un futuro:
* Mejorar la visualizaci√≥n de puntos para que se realice una visualizaci√≥n de puntos 3D mejorada. Desarrollar el software necesario para que toda la aplicaci√≥n funcione con esta visualizaci√≥n implementada que permita rotar la c√°mara:
![]()
* Mejorar la algor√≠tmica del robot para controlar mejor la profundidad y evitar cortes en el paciente. Sin embargo, para mejorar esto, es necesario lograr un meshing y texturizaci√≥n del modelo en la parte de Visi√≥n por Computadora para detectar correctamente todos los puntos con precisi√≥n. De esta manera, habr√≠a una mejor interacci√≥n Cirujano-Robot. Este trabajo es complicado y requiere mucho tiempo, pero creemos que es un desaf√≠o importante a superar, ya que el cambio que se puede lograr en el proyecto es significativo.
* Controlar la temperatura de los motores, mejorar la refrigeraci√≥n o cambiar el material de construcci√≥n del robot, ya que despu√©s de muchas pruebas o ejecuciones prolongadas, los engranajes m√°s peque√±os que est√°n en contacto directo con los motores se funden, perdiendo as√≠ el movimiento del robot.

# Autores:
* Pol Colomer Campoy (1605612) | PolKinsa
* Gerard Josep Guarin Velez (1605947) | GerardGV
* Jan Rubio Rico (1603753) | TheRospetit
* Rub√©n Sim√≥ Marin (1569391)

